"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3055],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return g}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(n),h=r,g=p["".concat(c,".").concat(h)]||p[h]||d[h]||s;return n?a.createElement(g,o(o({ref:t},u),{},{components:n})):a.createElement(g,o({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2288:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return d}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),o=n(4996),i=["components"],c={},l="Testing Smart Contracts",u={unversionedId:"developers/writing-onchain-code/testing-contracts",id:"developers/writing-onchain-code/testing-contracts",title:"Testing Smart Contracts",description:"Introduction",source:"@site/source/docs/casper/developers/writing-onchain-code/testing-contracts.md",sourceDirName:"developers/writing-onchain-code",slug:"/developers/writing-onchain-code/testing-contracts",permalink:"/developers/writing-onchain-code/testing-contracts",draft:!1,editUrl:"https://github.com/casper-network/docs-new/tree/dev-new/source/docs/casper/developers/writing-onchain-code/testing-contracts.md",tags:[],version:"current",lastUpdatedAt:1692636406,formattedLastUpdatedAt:"Aug 21, 2023",frontMatter:{},sidebar:"developers",previous:{title:"Writing a Basic Smart Contract in Rust",permalink:"/developers/writing-onchain-code/simple-contract"},next:{title:"Upgrading and Maintaining Smart Contracts",permalink:"/developers/writing-onchain-code/upgrading-contracts"}},p={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Defining Dependencies in <code>Cargo.toml</code>",id:"defining-dependencies-in-cargotoml",level:3},{value:"Setting up the Debugger and types of debugging",id:"setting-up-the-debugger-and-types-of-debugging",level:2},{value:"Debugging code using breakpoints in VS Code:",id:"debugging-code-using-breakpoints-in-vs-code",level:3},{value:"Debugging with macros",id:"debugging-with-macros",level:3},{value:"Writing the Tests",id:"writing-the-tests",level:2},{value:"Importing Builders and Constants",id:"importing-builders-and-constants",level:3},{value:"Creating a Test Function",id:"creating-a-test-function",level:3},{value:"Installing the Contract",id:"installing-the-contract",level:4},{value:"Calling the Contract by Hash",id:"calling-the-contract-by-hash",level:4},{value:"Calling the Contract using Session Code",id:"calling-the-contract-using-session-code",level:4},{value:"Evaluating and Comparing Results",id:"evaluating-and-comparing-results",level:4},{value:"Testing Contracts that Call Contracts",id:"testing-contracts-that-call-contracts",level:2},{value:"Running the Tests",id:"running-the-tests",level:2},{value:"Video Walkthrough",id:"video-walkthrough",level:2},{value:"Further Testing",id:"further-testing",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}],h={toc:d},g="wrapper";function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,s.kt)(g,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"testing-smart-contracts"},"Testing Smart Contracts"),(0,s.kt)("h2",{id:"introduction"},"Introduction"),(0,s.kt)("p",null,"As part of the Casper development environment, we provide a ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/casper-engine-test-support/latest/casper_engine_test_support/"},"testing framework")," to test new contracts without running a full node. The framework creates an instance of the Casper execution engine, which can confirm successful deploys and monitor changes to global state using assertions. The Casper test crate must be included within the Rust workspace alongside the Wasm-producing crate to be validated."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The Casper test support crate is one of many options for testing contracts before sending them to a Casper network."),(0,s.kt)("p",{parentName:"admonition"},"Independent of the framework, knowledge of setting up the debugger and logging the messages from the test execution will ensure, that the contract is fully functional before being deployed on the Casper network.")),(0,s.kt)("h3",{id:"defining-dependencies-in-cargotoml"},"Defining Dependencies in ",(0,s.kt)("inlineCode",{parentName:"h3"},"Cargo.toml")),(0,s.kt)("p",null,"This guide uses the project structure, and example contract outlined ",(0,s.kt)("a",{parentName:"p",href:"/developers/writing-onchain-code/simple-contract#directory-structure"},"here")," for creating tests."),(0,s.kt)("p",null,"To begin, outline the required test dependencies in the ",(0,s.kt)("inlineCode",{parentName:"p"},"/tests/Cargo.toml")," file. Specify the dependencies for your tests similarly and update the crate versions. Dependencies may vary with each project. For the counter tests, we have the following dependencies:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'[dependencies]\ncasper-execution-engine = "2.0.1"\ncasper-engine-test-support = { version = "2.2.0", features = ["test-support"] }\ncasper-types = "1.5.0"\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"casper-execution-engine")," - This crate imports the execution engine functionality, enabling Wasm execution within the test framework. Each node contains an instance of an execution engine, and the testing framework simulates this behavior."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"casper-engine-test-support")," - A helper crate that provides the interface to write tests and interact with an instance of the execution engine."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"casper-types")," - Types shared by many Casper crates for use on a Casper network.")),(0,s.kt)("h2",{id:"setting-up-the-debugger-and-types-of-debugging"},"Setting up the Debugger and types of debugging"),(0,s.kt)("p",null,"There are many ways to make sure that the code is written properly and will not cause any problems after being deployed on the blockchain. While having a good understating of Casper testing framework is crucial for a proper smart contract development, it is also necessary to know how to leverage other tools which will confirm that the logic in the smart contract is functioning properly. It was already mentioned that debugging in Rust is not active out of the box. There are some steps that need to be completed in order to be able to debug code in Rust."),(0,s.kt)("h3",{id:"debugging-code-using-breakpoints-in-vs-code"},"Debugging code using breakpoints in VS Code:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Set up CodeLLDB extension to be able to set up breakpoints in the code. This is a native debugger supporting C++, Rust and other compiled languages."),(0,s.kt)("li",{parentName:"ol"},"Go into the main project folder and type the command \u201cmake test\u201d in the VS Code Terminal. This will create the target folder."),(0,s.kt)("li",{parentName:"ol"},"Mark the tests.rs and from the toolbar in VS Code go to Run -> Start Debugging. This will create a new configuration for Rust."),(0,s.kt)("li",{parentName:"ol"},"You will be able to set breakpoints now."),(0,s.kt)("li",{parentName:"ol"},"There are two possibilities to run unit tests:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Either from the main project folder using the command \u201cmake test\u201d"),(0,s.kt)("li",{parentName:"ul"},"Or from the \u201ctests\u201d subfolder using the command \u201ccargo test\u201d")),(0,s.kt)("p",null,"Both variants will yield the same result which will run the tests and show if all were completed successfully."),(0,s.kt)("p",{align:"center"},(0,s.kt)("img",{src:(0,o.Z)("/image/testing-contracts/running-tests.png"),alt:"running-tests",width:"600"})),(0,s.kt)("p",null,"If you are completely sure that the code written in the unit tests is correct, then there is no further need to go deeper than that. It is advisable however to know what to do if you want to know how the code exactly works. The debug configuration needs to be set up in the following way, so it allows for the debugging of the tests."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'{\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "lldb",\n            "request": "launch",\n            "name": "Debug",\n            "program":  "${workspaceRoot}/default-project/tests/target/debug/deps/integration_tests-2771dd9bbf2fac3c",\n            "args": [],\n            "cwd": "${workspaceRoot}",\n            "sourceLanguages": [\n                "rust"\n            ]\n        }\n    ]\n}\n')),(0,s.kt)("p",null,"The most important is the program path which needs to be set exactly to the unit tests path seen during the \u201cmake test\u201d or \u201ccargo test\u201d unit tests run. In this case this would be ",(0,s.kt)("inlineCode",{parentName:"p"},"integration_tests-2771dd9bbf2fac3c"),"."),(0,s.kt)("ol",{start:6},(0,s.kt)("li",{parentName:"ol"},"Set the breakpoints in the unit tests file.")),(0,s.kt)("p",{align:"center"},(0,s.kt)("img",{src:(0,o.Z)("/image/testing-contracts/set-breakpoint.png"),alt:"set-breakpoint",width:"600"})),(0,s.kt)("ol",{start:7},(0,s.kt)("li",{parentName:"ol"},"Select the test.rs file and run the program in debug mode (F5).")),(0,s.kt)("p",{align:"center"},(0,s.kt)("img",{src:(0,o.Z)("/image/testing-contracts/caught-breakpoint.png"),alt:"caught-breakpoint",width:"600"})),(0,s.kt)("p",null,"This will allow you to see the parameters of the debugged unit tests."),(0,s.kt)("h3",{id:"debugging-with-macros"},"Debugging with macros"),(0,s.kt)("p",null,"A second most popular type of debugging is putting the \u201cprintln!\u201d Macro in the code so the parameters can be printed out during \u201ccargo test\u201d."),(0,s.kt)("p",{align:"center"},(0,s.kt)("img",{src:(0,o.Z)("/image/testing-contracts/println-macro.png"),alt:"println-macro",width:"600"})),(0,s.kt)("p",null,"It is important to note, that running \u201ccargo test\u201d without any parameters will not log the \u201cprintln!\u201d on the screen. For this to take effect the command"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"cargo test -- --nocapture\n")),(0,s.kt)("p",null,"must be used. This will produce the following outcome:"),(0,s.kt)("p",{align:"center"},(0,s.kt)("img",{src:(0,o.Z)("/image/testing-contracts/println-tests.png"),alt:"println-tests",width:"600"})),(0,s.kt)("p",null,"One thing that might be confusing is that although the macro is put in the first test function, it appears on top of the test stack. This is due to Rust running the tests in parallel. Those kinds of tests should be run targeting the function in question as to not introduce too much confusion during analysis."),(0,s.kt)("h2",{id:"writing-the-tests"},"Writing the Tests"),(0,s.kt)("p",null,"The tests for the contract usually reside in the ",(0,s.kt)("inlineCode",{parentName:"p"},"tests")," directory. Tests for the counter contract reside in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/counter/blob/master/tests/src/integration_tests.rs"},"tests/src/integration-tests.rs")," file. Notice that this file contains an empty ",(0,s.kt)("inlineCode",{parentName:"p"},"main")," method to initialize the test program. Alternatively, we could use the ",(0,s.kt)("inlineCode",{parentName:"p"},"#![no_main]")," annotation at the top of the file, as we did ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/counter/blob/8a622cd92d768893b9ef9fc2b150c674415be87e/contract-v1/src/main.rs#L1-L2"},"here"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n panic!("Execute \\"cargo test\\" to test the contract, not \\"cargo run\\".");\n}\n')),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"#[cfg(test)]")," attribute tells the Rust compiler to compile and run the tests only when invoking ",(0,s.kt)("inlineCode",{parentName:"p"},"cargo test"),", not while debugging or releasing. All testing functions reside within the grouping mechanism ",(0,s.kt)("inlineCode",{parentName:"p"},"mod tests"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(test)]\nmod tests {\n    // The entire test program resides here\n}\n")),(0,s.kt)("h3",{id:"importing-builders-and-constants"},"Importing Builders and Constants"),(0,s.kt)("p",null,"Import external test support, which includes a variety of default values and helper methods to be used throughout the test. Additionally, you will need to import any ",(0,s.kt)("a",{parentName:"p",href:"/developers/json-rpc/types_cl"},"CLTypes")," used within the contract code to be tested."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    // Outlining aspects of the Casper test support crate to include.\n    use casper_engine_test_support::{\n        ExecuteRequestBuilder, InMemoryWasmTestBuilder, DEFAULT_ACCOUNT_ADDR,\n        DEFAULT_RUN_GENESIS_REQUEST,\n    };\n    // Custom Casper types that will be used within this test.\n    use casper_types::{runtime_args, ContractHash, RuntimeArgs};\n")),(0,s.kt)("p",null,"Next, you need to define any global variables or constants for the test."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'    const COUNTER_V1_WASM: &str = "counter-v1.wasm"; // The first version of the contract\n    const COUNTER_V2_WASM: &str = "counter-v2.wasm"; // The second version of the contract\n    const COUNTER_CALL_WASM: &str = "counter-call.wasm"; // Session code that calls the contract\n\n    const CONTRACT_KEY: &str = "counter"; // Named key referencing this contract\n    const COUNT_KEY: &str = "count"; // Named key referencing the value to increment/decrement\n    const CONTRACT_VERSION_KEY: &str = "version"; // Key maintaining the version of a contract package\n\n    const ENTRY_POINT_COUNTER_DECREMENT: &str = "counter_decrement"; // Entry point to decrement the count value\n    const ENTRY_POINT_COUNTER_INC: &str = "counter_inc"; // Entry point to increment the count value\n')),(0,s.kt)("h3",{id:"creating-a-test-function"},"Creating a Test Function"),(0,s.kt)("p",null,"Each test function installs the contract and calls entry points to assert that the contract's behavior matches expectations. The test uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"InMemoryWasmTestBuilder")," to invoke an instance of the execution engine, effectively simulating the process of installing the contract on the chain."),(0,s.kt)("p",null,"As part of this process, we use the ",(0,s.kt)("inlineCode",{parentName:"p"},"DEFAULT_RUN_GENESIS_REQUEST")," to install the system contracts necessary for the tests, including the ",(0,s.kt)("inlineCode",{parentName:"p"},"Mint"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Auction"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"HandlePayment"),"contracts, as well as establishing a default account and funding the associated purse."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    #[test]\n    /// Install version 1 of the counter contract and check its available entry points. ...\n    fn install_version1_and_check_entry_points() {\n        let mut builder = InMemoryWasmTestBuilder::default();\n        builder.run_genesis(&*DEFAULT_RUN_GENESIS_REQUEST).commit();\n\n        // See the repository for the full function.\n    }\n")),(0,s.kt)("h4",{id:"installing-the-contract"},"Installing the Contract"),(0,s.kt)("p",null,"Test functions use the ",(0,s.kt)("inlineCode",{parentName:"p"},"ExecuteRequestBuilder")," to install a contract to be tested. In the counter tests, we use standard dependencies and the counter contract. Within the execution request, we specify the ",(0,s.kt)("inlineCode",{parentName:"p"},"DEFAULT_ACCOUNT_ADDR")," established by our genesis builder as the account sending the Deploy."),(0,s.kt)("p",null,"After building the ",(0,s.kt)("inlineCode",{parentName:"p"},"ExecuteRequestBuilder")," (in this example, ",(0,s.kt)("inlineCode",{parentName:"p"},"contract_installation_request"),"), we process the request through ",(0,s.kt)("inlineCode",{parentName:"p"},"builder.exec")," and then add and process other requests as necessary."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    // Install the contract.\n    let contract_v1_installation_request = ExecuteRequestBuilder::standard(\n        *DEFAULT_ACCOUNT_ADDR,\n        COUNTER_V1_WASM,\n        runtime_args! {},\n    )\n    .build();\n\n    builder\n        .exec(contract_v1_installation_request)\n        .expect_success()\n        .commit();\n")),(0,s.kt)("h4",{id:"calling-the-contract-by-hash"},"Calling the Contract by Hash"),(0,s.kt)("p",null,"To verify the installed contract, we need its contract hash. The test will then call its entry points using the ",(0,s.kt)("inlineCode",{parentName:"p"},"contract_call_by_hash")," function. The following code retrieves the contract hash from the named keys of the ",(0,s.kt)("inlineCode",{parentName:"p"},"DEFAULT_ACCOUNT_ADDR")," that sent the installation Deploy."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'    // Check the contract hash.\n    let contract_v1_hash = builder\n        .get_expected_account(*DEFAULT_ACCOUNT_ADDR)\n        .named_keys()\n        .get(CONTRACT_KEY)\n        .expect("must have contract hash key as part of contract creation")\n        .into_hash()\n        .map(ContractHash::new)\n        .expect("must get contract hash");\n')),(0,s.kt)("p",null,"Next, we test an entry point that should not exist in the first version of the contract."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    // Call the decrement entry point, which should not be in version 1 before the upgrade.\n    let contract_decrement_request = ExecuteRequestBuilder::contract_call_by_hash(\n        *DEFAULT_ACCOUNT_ADDR,\n        contract_v1_hash,\n        ENTRY_POINT_COUNTER_DECREMENT,\n        runtime_args! {},\n    )\n    .build();\n\n    // Try executing the decrement entry point and expect an error.\n    builder\n        .exec(contract_decrement_request)\n        .expect_failure()\n        .commit();\n")),(0,s.kt)("h4",{id:"calling-the-contract-using-session-code"},"Calling the Contract using Session Code"),(0,s.kt)("p",null,"In the counter example, we use the session code included in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/counter/blob/master/counter-call/src/main.rs"},"counter-call.wasm")," file. For more details on what session code is and how it differs from contract code, see the ",(0,s.kt)("a",{parentName:"p",href:"/developers/writing-onchain-code/contract-vs-session#what-is-session-code"},"next section"),"."),(0,s.kt)("p",null,"The following session code uses the contract hash to identify the contract, the account for sending the deploy (",(0,s.kt)("inlineCode",{parentName:"p"},"DEFAULT_ACCOUNT_ADDR"),"), the deploy to be sent (",(0,s.kt)("inlineCode",{parentName:"p"},"COUNTER_CALL_WASM"),"), and the runtime arguments required. Once again, the ",(0,s.kt)("inlineCode",{parentName:"p"},"ExecuteRequestBuilder")," simulates the execution of session code and calls the ",(0,s.kt)("inlineCode",{parentName:"p"},"counter-inc")," entry point."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    // Use session code to increment the counter.\n    let session_code_request = ExecuteRequestBuilder::standard(\n        *DEFAULT_ACCOUNT_ADDR,\n        COUNTER_CALL_WASM,\n        runtime_args! {\n            CONTRACT_KEY => contract_v1_hash\n        },\n    )\n    .build();\n\n    builder.exec(session_code_request)\n        .expect_success()\n        .commit();\n")),(0,s.kt)("h4",{id:"evaluating-and-comparing-results"},"Evaluating and Comparing Results"),(0,s.kt)("p",null,"After calling the contract, we should verify the results received to ensure the contract operated as intended. The ",(0,s.kt)("inlineCode",{parentName:"p"},"builder")," method retrieves the required information and converts it to the value type required. Then, ",(0,s.kt)("inlineCode",{parentName:"p"},"assert_eq!()")," compares the result against the expected value."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'    // Verify the value of count is now 1.\n    let incremented_count = builder\n        .query(None, count_key, &[])\n        .expect("should be stored value.")\n        .as_cl_value()\n        .expect("should be cl value.")\n        .clone()\n        .into_t::<i32>()\n        .expect("should be i32.");\n\n    assert_eq!(incremented_count, 1);\n')),(0,s.kt)("p",null,"For more test examples, visit the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-network/casper-node/tree/dev/smart_contracts/contracts/test"},"casper-node")," GitHub repository."),(0,s.kt)("h2",{id:"testing-contracts-that-call-contracts"},"Testing Contracts that Call Contracts"),(0,s.kt)("p",null,"If the code to be tested involves multiple contracts, they must be installed within the test. The exceptions are system contracts installed as part of the ",(0,s.kt)("inlineCode",{parentName:"p"},"DEFAULT_RUN_GENESIS_REQUEST"),". The testing framework exists independently of any Casper network, so you will need access to the original contract installation code or the Wasm you wish to include."),(0,s.kt)("p",null,"Each contract installation will require an additional Wasm file installed through a ",(0,s.kt)("inlineCode",{parentName:"p"},"Deploy")," using ",(0,s.kt)("inlineCode",{parentName:"p"},"ExecuteRequestBuilder"),". Depending on your requirements as a smart contract author, you may need to use ",(0,s.kt)("a",{parentName:"p",href:"/resources/tutorials/advanced/return-values-tutorial"},"return values")," to interact with stacks of contracts. Interaction between contracts will require session code to initiate the process, as contracts will not execute actions autonomously."),(0,s.kt)("p",null,"The major difference between calling a contract from session code versus contract code is the ability to use non-standard dependencies for the ",(0,s.kt)("inlineCode",{parentName:"p"},"ExecuteRequestBuilder"),". Where session code must designate a Wasm file within the standard dependencies, contract code can use one of the four available options for calling other contracts, namely:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"contract_call_by_hash")," - Calling a contract by its ",(0,s.kt)("inlineCode",{parentName:"li"},"ContractHash"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"contract_call_by_name")," - Calling a contract referenced by a named key in the signer's Account context."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"versioned_contract_call_by_hash")," - Calling a specific contract version using its ",(0,s.kt)("inlineCode",{parentName:"li"},"ContractHash"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"versioned_contract_call_by_name")," - Calling a specific version of a contract referenced by a named key in the signer's Account context.")),(0,s.kt)("p",null,"The calling contract must also provide an entry point and any necessary runtime arguments in all cases."),(0,s.kt)("h2",{id:"running-the-tests"},"Running the Tests"),(0,s.kt)("p",null,"To run the tests, the counter example uses a ",(0,s.kt)("inlineCode",{parentName:"p"},"Makefile"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"make test\n")),(0,s.kt)("p",null,"Under the hood, the ",(0,s.kt)("inlineCode",{parentName:"p"},"Makefile")," generates a ",(0,s.kt)("inlineCode",{parentName:"p"},"tests/wasm")," folder, copies the Wasm files to the folder, and runs the tests using ",(0,s.kt)("inlineCode",{parentName:"p"},"cargo test"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"test: build-contract\n    mkdir -p tests/wasm\n    cp contract-v1/target/wasm32-unknown-unknown/release/counter-v1.wasm tests/wasm\n    cp contract-v2/target/wasm32-unknown-unknown/release/counter-v2.wasm tests/wasm\n    cp counter-call/target/wasm32-unknown-unknown/release/counter-call.wasm tests/wasm\n    cd tests && cargo test\n")),(0,s.kt)("h2",{id:"video-walkthrough"},"Video Walkthrough"),(0,s.kt)("p",null,"The following brief video describes testing ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/counter/"},"sample contract code"),"."),(0,s.kt)("p",{align:"center"},(0,s.kt)("iframe",{width:"400",height:"225",src:"https://www.youtube.com/embed?v=sUg0nh3K3iQ&list=PL8oWxbJ-csEqi5FP87EJZViE2aLz6X1Mj&index=7",frameborder:"0",allow:"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),(0,s.kt)("h2",{id:"further-testing"},"Further Testing"),(0,s.kt)("p",null,"Unit testing is only one way to test contracts before installing them on a Casper network. After unit testing a contract, you may perform ",(0,s.kt)("a",{parentName:"p",href:"/developers/dapps/setup-nctl"},"local network testing")," using NCTL. This allows you to set up and control multiple local Casper nodes to perform ",(0,s.kt)("a",{parentName:"p",href:"/developers/dapps/nctl-test"},"testing in an other simulated network environment"),"."),(0,s.kt)("p",null,"You may also wish to test your contracts on the Casper ",(0,s.kt)("a",{parentName:"p",href:"https://testnet.cspr.live/"},"Testnet"),"."),(0,s.kt)("h2",{id:"whats-next"},"What's Next?"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Understand ",(0,s.kt)("a",{parentName:"li",href:"/developers/writing-onchain-code/contract-vs-session#what-is-session-code"},"session code")," and how it triggers a smart contract."),(0,s.kt)("li",{parentName:"ul"},"Learn to ",(0,s.kt)("a",{parentName:"li",href:"/developers/cli/installing-contracts"},"install a contract and query global state")," with the Casper command-line client.")))}m.isMDXComponent=!0}}]);