"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3550],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),g=a,h=d["".concat(c,".").concat(g)]||d[g]||u[g]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=g;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},7541:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return d}});var r=n(3117),a=n(102),o=(n(7294),n(3905)),i=["components"],s={},c="Reading and Writing Data to the Blockchain",l={unversionedId:"concepts/design/reading-and-writing-to-the-blockchain",id:"concepts/design/reading-and-writing-to-the-blockchain",title:"Reading and Writing Data to the Blockchain",description:"Casper features several means of reading and writing data to global state, depending on user needs and complexity. Reading data from global state can be done by dApps off-chain or by smart contracts on-chain. Writing data requires on-chain interactions due to the nature of the system. Storage in global state can be accomplished using Dictionaries or NamedKeys.",source:"@site/source/docs/casper/concepts/design/reading-and-writing-to-the-blockchain.md",sourceDirName:"concepts/design",slug:"/concepts/design/reading-and-writing-to-the-blockchain",permalink:"/concepts/design/reading-and-writing-to-the-blockchain",draft:!1,editUrl:"https://github.com/casper-network/docs/tree/main/source/docs/casper/concepts/design/reading-and-writing-to-the-blockchain.md",tags:[],version:"current",lastUpdatedAt:1681915652,formattedLastUpdatedAt:"Apr 19, 2023",frontMatter:{},sidebar:"concepts",previous:{title:"The Highway Consensus Protocol",permalink:"/concepts/design/highway"},next:{title:"Economics Overview",permalink:"/economics"}},p={},d=[{value:"Using the Casper JSON-RPC",id:"using-the-casper-json-rpc",level:2},{value:"Using the Casper Rust API",id:"using-the-casper-rust-api",level:2}],u={toc:d},g="wrapper";function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)(g,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"reading-and-writing-data-to-the-blockchain"},"Reading and Writing Data to the Blockchain"),(0,o.kt)("p",null,"Casper features several means of reading and writing data to global state, depending on user needs and complexity. Reading data from global state can be done by dApps off-chain or by smart contracts on-chain. Writing data requires on-chain interactions due to the nature of the system. Storage in global state can be accomplished using ",(0,o.kt)("a",{parentName:"p",href:"/concepts/dictionaries"},"Dictionaries")," or ",(0,o.kt)("a",{parentName:"p",href:"/developers/json-rpc/types_chain#namedkey"},(0,o.kt)("inlineCode",{parentName:"a"},"NamedKeys")),"."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Due to the nature of Casper's serialization standard, ",(0,o.kt)("inlineCode",{parentName:"p"},"NamedKeys")," should be used sparingly and only for small data sets. Developers should use dictionaries for larger mapped structures.")),(0,o.kt)("h2",{id:"using-the-casper-json-rpc"},"Using the Casper JSON-RPC"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/developers/json-rpc/json-rpc-informational#query-global-state"},(0,o.kt)("inlineCode",{parentName:"a"},"query_global_state"))," method available through the JSON-RPC allows users to read data from global state without performing on-chain actions. For more details, see the ",(0,o.kt)("a",{parentName:"p",href:"/resources/tutorials/beginner/querying-network"},"Querying a Casper Network")," tutorial."),(0,o.kt)("h2",{id:"using-the-casper-rust-api"},"Using the Casper Rust API"),(0,o.kt)("p",null,"The Casper API includes the following functions for reading and writing to global state:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/runtime/fn.put_key.html"},"put_key")," - Stores the given ",(0,o.kt)("inlineCode",{parentName:"li"},"Key")," under the given ",(0,o.kt)("inlineCode",{parentName:"li"},"name")," in the current context's named keys"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/runtime/fn.get_key.html"},"get_key")," - Returns the requested ",(0,o.kt)("inlineCode",{parentName:"li"},"NamedKey")," from the current context"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.new_uref.html"},"storage::new_uref")," - Creates a new URef in the current context"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.write.html"},"storage::write")," - Writes a given value under a previously created URef"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.read.html"},"storage::read")," - Reads the value from a URef in global state"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.dictionary_put.html"},"dictionary_put")," - Writes the given value under the given ",(0,o.kt)("inlineCode",{parentName:"li"},"dictionary_item_key")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.dictionary_get.html"},"dictionary_get")," - Retrieves the value stored under a ",(0,o.kt)("inlineCode",{parentName:"li"},"dictionary_item_key"))),(0,o.kt)("p",null,"For more details, see the ",(0,o.kt)("a",{parentName:"p",href:"/resources/tutorials/advanced/storage-workflow"},"Reading and Writing to Global State using Rust")," tutorial."))}h.isMDXComponent=!0}}]);