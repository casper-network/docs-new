"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2882],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return f}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,f=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3972:function(e,t,n){n.r(t),n.d(t,{assets:function(){return A},contentTitle:function(){return q},default:function(){return x},frontMatter:function(){return E},metadata:function(){return j},toc:function(){return D}});var a=n(3117),r=n(102),o=n(7294),i=n(3905),s=n(4334),l=n(2466),c=n(6550),u=n(1980),p=n(7392),d=n(12);function h(e){return function(e){return o.Children.map(e,(function(e){if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes,default:t.default}}))}function f(e){var t=e.values,n=e.children;return(0,o.useMemo)((function(){var e=null!=t?t:h(n);return function(e){var t=(0,p.l)(e,(function(e,t){return e.value===t.value}));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function m(e){var t=e.value;return e.tabValues.some((function(e){return e.value===t}))}function b(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId,r=(0,c.k6)(),i=function(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:n,groupId:a});return[(0,u._X)(i),(0,o.useCallback)((function(e){if(i){var t=new URLSearchParams(r.location.search);t.set(i,e),r.replace(Object.assign({},r.location,{search:t.toString()}))}}),[i,r])]}function y(e){var t,n,a,r,i=e.defaultValue,s=e.queryString,l=void 0!==s&&s,c=e.groupId,u=f(e),p=(0,o.useState)((function(){return function(e){var t,n=e.defaultValue,a=e.tabValues;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}var r=null!=(t=a.find((function(e){return e.default})))?t:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:i,tabValues:u})})),h=p[0],y=p[1],v=b({queryString:l,groupId:c}),k=v[0],g=v[1],w=(t=function(e){return e?"docusaurus.tab."+e:null}({groupId:c}.groupId),n=(0,d.Nk)(t),a=n[0],r=n[1],[a,(0,o.useCallback)((function(e){t&&r.set(e)}),[t,r])]),T=w[0],N=w[1],S=function(){var e=null!=k?k:T;return m({value:e,tabValues:u})?e:null}();return(0,o.useLayoutEffect)((function(){S&&y(S)}),[S]),{selectedValue:h,selectValue:(0,o.useCallback)((function(e){if(!m({value:e,tabValues:u}))throw new Error("Can't select invalid tab value="+e);y(e),g(e),N(e)}),[g,N,u]),tabValues:u}}var v=n(2389),k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){var t=e.className,n=e.block,r=e.selectedValue,i=e.selectValue,c=e.tabValues,u=[],p=(0,l.o5)().blockElementScrollPositionUntilNextRender,d=function(e){var t=e.currentTarget,n=u.indexOf(t),a=c[n].value;a!==r&&(p(t),i(a))},h=function(e){var t,n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":var a,r=u.indexOf(e.currentTarget)+1;n=null!=(a=u[r])?a:u[0];break;case"ArrowLeft":var o,i=u.indexOf(e.currentTarget)-1;n=null!=(o=u[i])?o:u[u.length-1]}null==(t=n)||t.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},t)},c.map((function(e){var t=e.value,n=e.label,i=e.attributes;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,key:t,ref:function(e){return u.push(e)},onKeyDown:h,onClick:d},i,{className:(0,s.Z)("tabs__item",k.tabItem,null==i?void 0:i.className,{"tabs__item--active":r===t})}),null!=n?n:t)})))}function w(e){var t=e.lazy,n=e.children,a=e.selectedValue;if(n=Array.isArray(n)?n:[n],t){var r=n.find((function(e){return e.props.value===a}));return r?(0,o.cloneElement)(r,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},n.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==a})})))}function T(e){var t=y(e);return o.createElement("div",{className:(0,s.Z)("tabs-container",k.tabList)},o.createElement(g,(0,a.Z)({},e,t)),o.createElement(w,(0,a.Z)({},e,t)))}function N(e){var t=(0,v.Z)();return o.createElement(T,(0,a.Z)({key:String(t)},e))}var S={tabItem:"tabItem_Ymn6"};function C(e){var t=e.children,n=e.hidden,a=e.className;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(S.tabItem,a),hidden:n},t)}var O=["components"],E={},q="dApp Technology Stack",j={unversionedId:"developers/dapps/technology-stack",id:"developers/dapps/technology-stack",title:"dApp Technology Stack",description:"There are 3 layers to building a decentralized application that interacts with the Casper Network: Front-end, backend, and blockchain. This document outlines lists the requirements for each.",source:"@site/source/docs/casper/developers/dapps/technology-stack.md",sourceDirName:"developers/dapps",slug:"/developers/dapps/technology-stack",permalink:"/developers/dapps/technology-stack",draft:!1,editUrl:"https://github.com/casper-network/docs/tree/main/source/docs/casper/developers/dapps/technology-stack.md",tags:[],version:"current",lastUpdatedAt:1679068902,formattedLastUpdatedAt:"Mar 17, 2023",frontMatter:{},sidebar:"developers",previous:{title:"Python SDK",permalink:"/developers/dapps/sdk/python-sdk"},next:{title:"Signing Deploys",permalink:"/developers/dapps/signing-a-deploy"}},A={},D=[{value:"Front-end",id:"front-end",level:2},{value:"Signing Transactions",id:"signing-transactions",level:3},{value:"Querying the Blockchain State",id:"querying-the-blockchain-state",level:3},{value:"Backend",id:"backend",level:2},{value:"Blockchain",id:"blockchain",level:2}],I={toc:D},P="wrapper";function x(e){var t=e.components,n=(0,r.Z)(e,O);return(0,i.kt)(P,(0,a.Z)({},I,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dapp-technology-stack"},"dApp Technology Stack"),(0,i.kt)("p",null,"There are 3 layers to building a decentralized application that interacts with the Casper Network: Front-end, backend, and blockchain. This document outlines lists the requirements for each."),(0,i.kt)("h2",{id:"front-end"},"Front-end"),(0,i.kt)("p",null,'The front-end, or "client-side" of a dApp consists of the interface that the user uses to interact with the smart contracts on the Casper Network. This interface usually comes in the form of a website/webpage, mobile device application, or computer program, but could also include APIs with callable/queryable endpoints.'),(0,i.kt)("p",null,"You will need to choose a Casper-compatible SDK for the language you are using to call and query smart contracts on the Network. Casper's SDKs have methods available for constructing deployments and gathering state data. While these interactions can be prepared on the front-end, they must be sent to the backend of your application before being sent off to the Network, so as to fulfill ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"},"CORS")," requirements."),(0,i.kt)("h3",{id:"signing-transactions"},"Signing Transactions"),(0,i.kt)("p",null,"The signing of transactions will in many cases need to be performed by the user on the front-end, for which you may implement one or more of a few different options:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The Casper Signer"),(0,i.kt)("p",{parentName:"li"},"The Casper JS SDK has a class ",(0,i.kt)("inlineCode",{parentName:"p"},"Signer")," that, when implemented, allows a user to sign transactions using the Casper Signer browser extension. Deploy objects are first converted to JSON, then sent to the Signer to be signed, then must be sent to the backend for deployment to a node.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Third-party signers"),(0,i.kt)("p",{parentName:"li"},"Third-party signers may be used as well. A JSON representation of the unsigned transaction should be forwarded to the third-party signer and accept a callback containing the signed deploy object.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Pasted private key (not recommended)"),(0,i.kt)("p",{parentName:"li"},"It is also possible to allow a user to paste/type in their private key to be used to sign the transaction. This is not recommended for security reasons."))),(0,i.kt)("h3",{id:"querying-the-blockchain-state"},"Querying the Blockchain State"),(0,i.kt)("p",null,"To execute a blockchain state query, like retreiving smart contract data or getting current chain information, the preparation may be done on the front-end, but the query to a node must ultimately originate from your application's backend. This preparatory stage comes only in the form of defining a contract hash and the path which you'd like to query data, or for chain information, the endpoint you'd like to query."),(0,i.kt)("h2",{id:"backend"},"Backend"),(0,i.kt)("p",null,"The backend of a dApp consists of the server-side code that connects the blockchain to the front-end interface, and deals with data-parsing and app-layer communication. A backend server is necessary for building dApps on Casper as Casper's nodes expect ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"},"CORS headers")," from a specified origin on HTTP requests they receive. Backend servers are helpful for other reasons too, such as queueing requests and analyzing the traffic moving between your dApp and the blockchain."),(0,i.kt)("p",null,"As the backend (server) of a dApp is the software communicating with Casper nodes, and therefore the blockchain, it is what needs to be given information such as which node to connect to, and which endpoints to communicate with."),(0,i.kt)(N,{mdxType:"Tabs"},(0,i.kt)(C,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const client = new CasperClient("http://NODE_ADDRESS:7777/rpc");\n'))),(0,i.kt)(C,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'client = NodeClient(NodeConnection((host = "NODE_ADDRESS"), (port_rpc = 7777)));\n')))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: You can find online peers for mainnet at ",(0,i.kt)("a",{parentName:"em",href:"https://cspr.live"},"cspr.live")," or testnet at ",(0,i.kt)("a",{parentName:"em",href:"https://testnet.cspr.live"},"testnet.cspr.live"))),(0,i.kt)("p",null,"There are two main types of queries that will be sent from the backend to the blockchain, transactions and queries. In the case of a dApp, these will both originate from the front-end."),(0,i.kt)("p",null,"Blockchain interaction for state queries is handled solely on the backend, where on the front-end, a user simply chooses the path at which they want to query data. This path is sent to the backend where the server will perform the state query and send the result back to the front-end."),(0,i.kt)("p",null,"In the case of a user-signed transaction originating from the dApp's front-end, the backend will need to accept this transaction and forward it to the Casper Network. This is often accomplished by opening a POST endpoint that accepts JSON formatted transactions and forwards them along."),(0,i.kt)("h2",{id:"blockchain"},"Blockchain"),(0,i.kt)("p",null,"The last stop for a transaction or query is the blockchain itself. Like the majority of smart contract blockchains, the Casper Network maintains a forever-growing, immutable ledger that can be read and written to. When building a dApp for the Casper Network, user interactions in the form of queries and transactions originate from the front-end, are forwarded to the backend, and are then sent to a Casper node for interaction with the blockchain. Casper nodes can be communicated with via JSON RPC calls, and have a variety of open ",(0,i.kt)("a",{parentName:"p",href:"/developers/json-rpc/json-rpc-transactional"},"transactional"),", ",(0,i.kt)("a",{parentName:"p",href:"/developers/json-rpc/json-rpc-informational"},"informational"),", and ",(0,i.kt)("a",{parentName:"p",href:"/developers/json-rpc/json-rpc-pos"},"Proof-of-Stake")," endpoints. By utilizing an SDK on the backend, you won't need to construct these JSON RPC calls yourself, they'll be done for you within the available methods."),(0,i.kt)("p",null,"More than likely, you will want your dApp to perform personalized functions, store custom data, and perhaps even store or transact upon tokens with monetary value. All of these behaviors can be implemented by writing custom smart contracts for your application. Smart contracts on the Casper Network can perform any function that a classical computer can. Casper's smart contracts are executed as ",(0,i.kt)("a",{parentName:"p",href:"https://webassembly.org/"},"WebAssembly")," binaries, and can be written in any language that compiles to WebAssembly. Currently, most developers choose to write their smart contracts in ",(0,i.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/"},"Rust")," for its reliability and ease-of-use. Additionally, Casper's smart contract documentation is written for Rust."),(0,i.kt)("p",null,"To learn how to write smart contracts for your dApp, read the ",(0,i.kt)("a",{parentName:"p",href:"about:blank"},"smart contract documentation"),"."))}x.isMDXComponent=!0}}]);