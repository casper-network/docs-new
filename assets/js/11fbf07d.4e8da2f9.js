"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1677],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return m}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),h=c(a),u=o,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||i;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,s=new Array(i);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[h]="string"==typeof e?e:o,s[1]=r;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5415:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return h}});var n=a(3117),o=a(102),i=(a(7294),a(3905)),s=["components"],r={},l="Overview of a Casper Network",c={unversionedId:"concepts/design/casper-design",id:"concepts/design/casper-design",title:"Overview of a Casper Network",description:"Introduction",source:"@site/source/docs/casper/concepts/design/casper-design.md",sourceDirName:"concepts/design",slug:"/concepts/design/casper-design",permalink:"/concepts/design/casper-design",draft:!1,editUrl:"https://github.com/casper-network/docs/tree/main/source/docs/casper/concepts/design/casper-design.md",tags:[],version:"current",lastUpdatedAt:1679910209,formattedLastUpdatedAt:"Mar 27, 2023",frontMatter:{},sidebar:"concepts",previous:{title:"The Highway Consensus Protocol",permalink:"/concepts/design/highway"},next:{title:"Reading and Writing Data to the Blockchain",permalink:"/concepts/design/reading-and-writing-to-the-blockchain"}},p={},h=[{value:"Introduction",id:"introduction",level:2},{value:"Global State",id:"global-state-head",level:2},{value:"Merkle Trie Structure",id:"global-state-trie",level:3},{value:"Execution Semantics",id:"execution-semantics-head",level:2},{value:"Measuring Computational Work",id:"execution-semantics-gas",level:3},{value:"Deploys",id:"execution-semantics-deploys",level:3},{value:"Deploy Lifecycle",id:"execution-semantics-phases",level:3},{value:"Deploy Received",id:"deploy-received",level:4},{value:"Deploy Gossiped",id:"deploy-gossiped",level:4},{value:"Block Proposed",id:"block-proposed",level:4},{value:"Block Gossiped",id:"block-gossiped",level:4},{value:"Consensus Reached",id:"consensus-reached",level:4},{value:"Deploy Executed",id:"deploy-executed",level:4},{value:"The Casper Network Runtime",id:"execution-semantics-runtime",level:3},{value:"Generating <code>URef</code>s",id:"execution-semantics-urefs",level:4},{value:"Accounts",id:"accounts-head",level:2},{value:"Creating an account",id:"accounts-creating",level:3},{value:"Permissions Model",id:"accounts-permissions",level:3},{value:"Actions and Thresholds",id:"accounts-actions-thresholds",level:4},{value:"Associated Keys and Weights",id:"accounts-associated-keys-weights",level:4},{value:"Key Management Actions",id:"accounts-key-management",level:4},{value:"Account security and recovery using key management",id:"accounts-recovery",level:4},{value:"The Account Context",id:"accounts-context",level:3},{value:"Unforgeable Reference (URef)",id:"uref-head",level:2},{value:"Permissions for <code>URef</code>s",id:"uref-permissions",level:3},{value:"<code>URef</code>s and Purses",id:"urefs-and-purses",level:3},{value:"Block Structure",id:"block-structure-head",level:2},{value:"Data Fields",id:"block-structure-data",level:3},{value:"<code>block_hash</code>",id:"block_hash",level:4},{value:"Header",id:"header",level:4},{value:"Body",id:"body",level:4},{value:"Tokens",id:"tokens-head",level:2},{value:"Token Generation and Distribution",id:"token-generation-and-distribution",level:3},{value:"Divisibility of Tokens",id:"tokens-divisibility",level:3},{value:"Purses and Accounts",id:"tokens-purses-and-accounts",level:3},{value:"The Casper Mint Contract",id:"mint-contract",level:3},{value:"The mint Contract Interface",id:"tokens-mint-interface",level:2}],d={toc:h},u="wrapper";function m(e){var t=e.components,r=(0,o.Z)(e,s);return(0,i.kt)(u,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"overview-of-a-casper-network"},"Overview of a Casper Network"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Casper is a Proof-of-Stake blockchain platform with an account-based model that performs execution after consensus. A Casper network stores data on a structure known as ",(0,i.kt)("a",{parentName:"p",href:"#global-state-head"},"Global State"),". Users interact with global state through session code sent in a ",(0,i.kt)("a",{parentName:"p",href:"#execution-semantics-deploys"},"Deploy"),". Deploys contain ",(0,i.kt)("a",{parentName:"p",href:"https://webassembly.org/"},"Wasm")," to be executed by the network, thus allowing developers to use their preferred programming language rather than a proprietary language."),(0,i.kt)("p",null,"A deploy executes in the context of the user's ",(0,i.kt)("a",{parentName:"p",href:"#accounts-head"},"Account")," but can call stored Wasm that will execute in its own context. User-related information other than an account is stored in global state as an ",(0,i.kt)("a",{parentName:"p",href:"#uref-head"},"Unforgeable Reference")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),". After a node accepts a deploy as valid, it places the deploy in a proposed ",(0,i.kt)("a",{parentName:"p",href:"#block-structure-head"},"Block")," and gossips it among nodes until the network reaches consensus. At this point, the network executes the Wasm included within the deploy."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#global-state-head"},"Global State"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#execution-semantics-head"},"Execution Semantics"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#accounts-head"},"Accounts"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#uref-head"},"Unforgeable Reference (URef)"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#block-structure-head"},"Block Structure"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#tokens-head"},"Tokens")))),(0,i.kt)("h2",{id:"global-state-head"},"Global State"),(0,i.kt)("p",null,'"Global state" is the storage layer for the Casper blockchain. All accounts, contracts, and any associated data are stored in global state. Global state follows the semantics of a key-value store (with additional permissions logic, as not all users can access all values in the same way).'),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Refer to ",(0,i.kt)("a",{parentName:"p",href:"/concepts/serialization-standard#serialization-standard-state-keys"},"Keys and Permissions")," for further information on keys.")),(0,i.kt)("p",null,"Changes to global state occur through executing deploys contained within finalized blocks. For validators to efficiently judge the correctness of these changes, they need information about the new state communicated succinctly. Further, the network must communicate portions of global state to users while allowing them to verify the correctness of the parts they receive. The key-value store is implemented as a ",(0,i.kt)("a",{parentName:"p",href:"#global-state-trie"},"Merkle trie")," for these reasons."),(0,i.kt)("h3",{id:"global-state-trie"},"Merkle Trie Structure"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Global State",src:a(7388).Z,width:"1111",height:"1021"})),(0,i.kt)("p",null,"At a high level, a Merkle trie is a key-value store data structure that can be shared piecewise in a verifiable way (via a construction called a Merkle proof). Each node is labeled by the hash of its data. Leaf nodes are labeled with the hash of their data. Non-leaf nodes are labeled with the hash of the labels of their child nodes."),(0,i.kt)("p",null,"Casper's implementation of the trie has radix of 256, meaning each branch node can have up to 256 children. A path through the tree can be an array of bytes, and serialization directly links a key with a path through the tree as its associated value."),(0,i.kt)("p",null,"Formally, a trie node is one of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a leaf, which includes a key and a value"),(0,i.kt)("li",{parentName:"ul"},"a branch, which has up to 256 ",(0,i.kt)("inlineCode",{parentName:"li"},"blake2b256")," hashes, pointing to up to 256 other nodes in the trie (recall each node is labeled by its hash)"),(0,i.kt)("li",{parentName:"ul"},"an extension node, which includes a byte array (called the affix) and a ",(0,i.kt)("inlineCode",{parentName:"li"},"blake2b256")," hash pointing to another node in the trie")),(0,i.kt)("p",null,"The purpose of the extension node is to allow path compression. Consider an example where all keys use the same first four bytes for values in the trie. In this case, it would be inefficient to traverse through four branch nodes where there is only one choice; instead, the root node of the trie could be an extension node with an affix equal to those first four bytes and a pointer to the first non-trivial branch node."),(0,i.kt)("p",null,"The Rust implementation of Casper's trie can be found on GitHub:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/casper-network/casper-node/blob/dev/execution_engine/src/storage/trie/mod.rs#L475"},"Definition of the trie data structure")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/casper-network/casper-node/blob/dev/execution_engine/src/storage/trie_store/operations/mod.rs#L45"},"Reading from the trie")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/casper-network/casper-node/blob/dev/execution_engine/src/storage/trie_store/operations/mod.rs#L954"},"Writing to the trie"))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Conceptually, each block has its trie because the state changes based on the deploys it contains. For this reason, Casper's implementation has a notion of a ",(0,i.kt)("inlineCode",{parentName:"p"},"TrieStore"),", which allows us to look up the root node for each trie.")),(0,i.kt)("h2",{id:"execution-semantics-head"},"Execution Semantics"),(0,i.kt)("p",null,"A Casper network is a decentralized computation platform. This section describes aspects of the Casper computational model."),(0,i.kt)("h3",{id:"execution-semantics-gas"},"Measuring Computational Work"),(0,i.kt)("p",null,"Computation is done in a ",(0,i.kt)("a",{parentName:"p",href:"https://webassembly.org/"},"WebAssembly (Wasm)")," interpreter, allowing any programming language which compiles to Wasm to become a smart contract language for the Casper blockchain. Similar to Ethereum, Casper uses ",(0,i.kt)("a",{parentName:"p",href:"/concepts/economics/gas-concepts"},(0,i.kt)("inlineCode",{parentName:"a"},"Gas"))," to measure computational work in a way that is consistent from node to node in a Casper network. Each Wasm opcode is assigned a ",(0,i.kt)("inlineCode",{parentName:"p"},"Gas")," cost, and the amount of gas spent is tracked by the runtime with each opcode executed by the interpreter."),(0,i.kt)("p",null,"Costs for opcode instructions on the Casper Mainnet network can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/casper-network/casper-node/blob/dev/resources/production/chainspec.toml#L115"},"here"),"."),(0,i.kt)("p",null,"All executions are finite because each has a finite ",(0,i.kt)("em",{parentName:"p"},"gas limit")," that specifies the maximum amount of gas available to spend before the runtime terminates the computation. The payment executable session determines how to pay for the deploy. The gas limit is set by executing the payment code specified within the deploy."),(0,i.kt)("p",null,"Although the network measures costs in ",(0,i.kt)("inlineCode",{parentName:"p"},"Gas"),", payment for computation occurs in ",(0,i.kt)("a",{parentName:"p",href:"#tokens-divisibility"},"motes"),". Therefore, there is a conversion rate between ",(0,i.kt)("inlineCode",{parentName:"p"},"Gas")," and motes."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Please note that Casper will not refund any amount of unused gas."),(0,i.kt)("p",{parentName:"admonition"},"This decision is taken to incentivize the ",(0,i.kt)("a",{parentName:"p",href:"/runtime#runtime-economics"},"Casper Runtime Economics")," by efficiently allocating the computational resources. The ",(0,i.kt)("a",{parentName:"p",href:"/runtime#consensus-before-execution-basics-of-payment"},"consensus-before-execution model")," implements the mechanism to encourage the optimized gas consumption from users and to prevent the overuse of block space by poorly handled deploys.")),(0,i.kt)("h3",{id:"execution-semantics-deploys"},"Deploys"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/concepts/serialization-standard#serialization-standard-deploy"},"Deploy")," is a data structure containing Wasm and the requester's signature(s). Additionally, the deploy header contains additional metadata about the deploy itself. A deploy\u2019s structure is as follows:"),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/image/design/deploy-structure.png",alt:"Image showing the deploy data structure",width:"500"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Body: Containing payment code and session code (more details on these below)"),(0,i.kt)("li",{parentName:"ul"},"Header: containing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"/concepts/serialization-standard#publickey"},"Public Key")," of the account in whose context the deploy will run"),(0,i.kt)("li",{parentName:"ul"},"The timestamp of the deploy\u2019s creation"),(0,i.kt)("li",{parentName:"ul"},"A time-to-live, after which the deploy expires and cannot be included in a block"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"blake2b256")," hash of the body"))),(0,i.kt)("li",{parentName:"ul"},"Deploy hash: the ",(0,i.kt)("inlineCode",{parentName:"li"},"blake2b")," hash of the Header"),(0,i.kt)("li",{parentName:"ul"},"Approvals: the set of signatures which have signed the deploy hash; these are used in the ",(0,i.kt)("a",{parentName:"li",href:"#accounts-associated-keys-weights"},"account permissions model"))),(0,i.kt)("h3",{id:"execution-semantics-phases"},"Deploy Lifecycle"),(0,i.kt)("p",null,"A deploy goes through the following phases on Casper:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Deploy Received"),(0,i.kt)("li",{parentName:"ol"},"Deploy Gossiped"),(0,i.kt)("li",{parentName:"ol"},"Block Proposed"),(0,i.kt)("li",{parentName:"ol"},"Block Gossiped"),(0,i.kt)("li",{parentName:"ol"},"Consensus Reached"),(0,i.kt)("li",{parentName:"ol"},"Deploy Executed")),(0,i.kt)("h4",{id:"deploy-received"},"Deploy Received"),(0,i.kt)("p",null,"A client sending the deploy will send it to one or more nodes via their JSON RPC servers. The node will ensure that a given deploy matches configuration settings outlined in the network's chainspec. Deploy configuration for the Casper Mainnet can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/casper-network/casper-node/blob/dev/resources/production/chainspec.toml#L79"},"here"),". Once accepted, the system returns the deploy hash to the client to indicate it has been enqueued for execution. The deploy could expire while waiting to be gossiped; whenever this happens, a ",(0,i.kt)("inlineCode",{parentName:"p"},"DeployExpired")," event is emitted by the event stream servers of all nodes which have the expired deploy."),(0,i.kt)("h4",{id:"deploy-gossiped"},"Deploy Gossiped"),(0,i.kt)("p",null,"After a node accepts a new deploy, it will gossip to all other nodes. A validator node will put the deploy into the block proposer buffer. The validator leader will pick the deploy from the block proposer buffer to create a new proposed block for the chain. This mechanism is efficient and ensures all nodes in the network eventually hold the given deploy. Each node that accepts a gossiped deploy also emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"DeployAccepted")," event on its event stream server. The deploy may expire while waiting for a node to add it to the block. Whenever this happens, the node emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"DeployExpired")," event."),(0,i.kt)("h4",{id:"block-proposed"},"Block Proposed"),(0,i.kt)("p",null,"The validator leader for this round will propose a block that includes as many deploys from the block proposer buffer as can fit in a block."),(0,i.kt)("h4",{id:"block-gossiped"},"Block Gossiped"),(0,i.kt)("p",null,"The proposed block propagates to all other nodes."),(0,i.kt)("h4",{id:"consensus-reached"},"Consensus Reached"),(0,i.kt)("p",null,"Once the other validators reach consensus that the proposed block is valid, all deploys in the block are executed, and this block becomes the final block added to the chain. Whenever reaching consensus, the event stream server emits a ",(0,i.kt)("inlineCode",{parentName:"p"},"BlockAdded"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"FinalitySignature")," events emit shortly after that. Finality signatures for the new block arrive from the validators."),(0,i.kt)("h4",{id:"deploy-executed"},"Deploy Executed"),(0,i.kt)("p",null,"A deploy executes in distinct phases to accommodate flexibly paying for computation. The phases of a deploy are ",(0,i.kt)("em",{parentName:"p"},"payment"),", ",(0,i.kt)("em",{parentName:"p"},"session"),", and ",(0,i.kt)("em",{parentName:"p"},"finalization"),". Payment code executes during the payment phase. If it is successful, the session code executes during the session phase. And, independently of session code execution, the finalization phase does some bookkeeping around the payment. Once the deploy is executed, a ",(0,i.kt)("inlineCode",{parentName:"p"},"DeployProcessed")," event is emitted by the event stream server."),(0,i.kt)("p",null,"In the event of execution failure, the sender will be charged the minimum penalty payment - 2.5 CSPR on the Casper Mainnet. This prevents malicious spamming of faulty deploys."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Payment code")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Payment code")," determines the payment amount for the computation requested and how much the sender is willing to pay. Payment code may include arbitrary logic, providing flexibility in paying for a deploy. For example, the simplest payment code could use the account's ",(0,i.kt)("a",{parentName:"p",href:"#tokens-purses-and-accounts"},"main purse"),". In contrast, an enterprise application may require a multi-signature scheme that accesses a corporate purse. To ensure the payment code will pay for its own computation, only accounts with a balance in their main purse greater than or equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"MAX_PAYMENT_COST")," may execute deploys. Based on the current conversion rate between gas and motes, we restrict the gas limit of the payment code execution so that the process spends no more than ",(0,i.kt)("inlineCode",{parentName:"p"},"MAX_PAYMENT_COST")," motes (a constant of the system.) If the payment is absent or not enough, then payment execution is not successful. In this case, the effects of the payment code on global state are reverted, and the system covers the cost of the computation with motes taken from the offending account's main purse."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Session code")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Session code")," provides the main logic for the deploy. It only executes if the payment code is successful. The gas limit for this computation is determined based on the amount of payment given (after subtracting the cost of the payment code itself)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Specifying payment code and session code")),(0,i.kt)("p",null,"The user-defined logic of a deploy can be specified in a number of ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a Wasm module in binary format representing valid session code, including logic to be executed in the context of an account or to store Wasm in the form of a contract to be executed later. (Note that the named keys from the context of the account the deploy is running in.)"),(0,i.kt)("li",{parentName:"ul"},"a 32-byte identifier representing the ",(0,i.kt)("a",{parentName:"li",href:"/concepts/serialization-standard#serialization-standard-hash-key"},"hash")," where a contract is already stored in the global state"),(0,i.kt)("li",{parentName:"ul"},"a name corresponding to a named key in the account, where a contract is stored under the key")),(0,i.kt)("p",null,"Payment and session code can be independently specified, so different methods of specifying them may be used (e.g. payment could be specified by a hash key, while the session is explicitly provided as a Wasm module)."),(0,i.kt)("h3",{id:"execution-semantics-runtime"},"The Casper Network Runtime"),(0,i.kt)("p",null,"A Wasm module is not natively able to create any effects outside of reading or writing from its own linear memory. Wasm modules must import functions from the host environment they are running in to enable other desired effects, such as reading or writing to global state."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Casper Network Runtime",src:a(9872).Z,width:"1220",height:"604"})),(0,i.kt)("p",null,"All these features are accessible via functions in the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/casper-contract/1.4.4/casper_contract/ext_ffi/index.html"},"Casper External FFI"),"."),(0,i.kt)("h4",{id:"execution-semantics-urefs"},"Generating ",(0,i.kt)("inlineCode",{parentName:"h4"},"URef"),"s"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s are generated using a ",(0,i.kt)("a",{parentName:"p",href:"https://rust-random.github.io/rand/rand_chacha/struct.ChaCha20Rng.html"},"cryptographically secure random number generator")," using the ",(0,i.kt)("a",{parentName:"p",href:"https://cr.yp.to/chacha.html"},"ChaCha algorithm"),". The random number generator is seeded by taking the ",(0,i.kt)("inlineCode",{parentName:"p"},"blake2b256")," hash of the deploy hash concatenated with an index representing the current phase of execution (to prevent collisions between ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s generated in different phases of the same deploy)."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Generating URefs",src:a(6125).Z,width:"1121",height:"289"})),(0,i.kt)("h2",{id:"accounts-head"},"Accounts"),(0,i.kt)("p",null,"The Casper blockchain uses an on-chain account-based model, uniquely identified by an ",(0,i.kt)("inlineCode",{parentName:"p"},"AccountHash")," derived from a specific ",(0,i.kt)("inlineCode",{parentName:"p"},"PublicKey"),". The ",(0,i.kt)("a",{parentName:"p",href:"#global-state-trie"},"global state trie store")," requires all keys to be the same length, so the AccountHash is a 32-byte derivative used to abstract any of the supported public key variants."),(0,i.kt)("p",null,"The Casper platform supports two types of keys for creating accounts and signing transactions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/concepts/accounts-and-keys#eddsa-keys"},"ed25519")," keys, which use the Edwards-curve Digital Signature Algorithm (EdDSA) and are 66 bytes long"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/concepts/accounts-and-keys#ethereum-keys"},"secp256k1")," keys, commonly known as Ethereum keys, which are 68 bytes long")),(0,i.kt)("p",null,'By default, a transactional interaction with the blockchain takes the form of a Deploy cryptographically signed by the key-pair corresponding to the PublicKey used to create the account. All user activity on the Casper blockchain (i.e., "deploys") must originate from an account. Each account has its own context where it can locally store information (e.g., references to useful contracts, metrics, and aggregated data from other parts of the blockchain). Each account also has a "main purse" where it can hold Casper tokens (see ',(0,i.kt)("a",{parentName:"p",href:"#tokens-purses-and-accounts"},"Tokens")," for more information)."),(0,i.kt)("p",null,"This chapter describes the permission model for accounts and their local storage capabilities and briefly mentions some runtime functions for interacting with accounts."),(0,i.kt)("h3",{id:"accounts-creating"},"Creating an account"),(0,i.kt)("p",null,"Account creation automatically happens upon transferring tokens to a yet unused ",(0,i.kt)("inlineCode",{parentName:"p"},"PublicKey"),". On account creation, the balance of its main purse is equal to the number of tokens transferred during the creation process. Its action thresholds are equal to 1, and there is one associated key. The associated key is the ",(0,i.kt)("inlineCode",{parentName:"p"},"PublicKey")," used to create the account. In this way, an account is essentially a context object encapsulating the main purse, used to pay for transactions. However, an account may have an additional purse beyond the main purse."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/image/design/account-structure.png",alt:"Image showing the account data structure",width:"200"})),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"Account")," contains the following data:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"URef"),' representing the account\'s "main purse"'),(0,i.kt)("li",{parentName:"ul"},"A collection of named keys (playing the same role as the named keys in a stored contract)"),(0,i.kt)("li",{parentName:"ul"},'A collection of "associated keys" (see ',(0,i.kt)("a",{parentName:"li",href:"#accounts-associated-keys-weights"},"below for more information"),")"),(0,i.kt)("li",{parentName:"ul"},'"Action thresholds" (see ',(0,i.kt)("a",{parentName:"li",href:"#accounts-actions-thresholds"},"below for more information"),")")),(0,i.kt)("h3",{id:"accounts-permissions"},"Permissions Model"),(0,i.kt)("h4",{id:"accounts-actions-thresholds"},"Actions and Thresholds"),(0,i.kt)("p",null,"An account can perform two types of actions: sending deploys and managing keys. A deploy is simply executing some code on the blockchain, while key management involves changing the associated keys (which will be described in more detail later). Key management cannot be performed independently, as all effects on the blockchain must come via a deploy; therefore, a key management action implies that a deploy action is also taking place."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ActionThresholds")," contained in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Account")," data structure set a ",(0,i.kt)("inlineCode",{parentName:"p"},"Weight"),", which must be met to perform that action. The next section describes these weight thresholds. Since a key management action requires a deploy action, the key management threshold should always be greater than or equal to the deploy threshold."),(0,i.kt)("h4",{id:"accounts-associated-keys-weights"},"Associated Keys and Weights"),(0,i.kt)("p",null,"Accounts on a Casper network can associate other key pairs through a multiple signature scheme for sending transactions. An account's ",(0,i.kt)("em",{parentName:"p"},"associated keys"),' are the set of public keys allowed to provide signatures on deploys for that account. Each associated key has a weight; these weights combine to meet the action thresholds provided in the previous section. Each deploy must be signed by one or more keys associated with the account that deploy is for, and the sum of the weights of those keys must be greater than or equal to the deployment threshold weight for that account. We call the keys that have signed a deploy the "authorizing keys". Similarly, if a deploy contains key management actions (detailed below), the sum of the weights of the authorizing keys must be greater than or equal to the key management action threshold of the account.'),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'Any key may help authorize any action; there are no "special keys". All keys contribute their weight in exactly the same way.')),(0,i.kt)("h4",{id:"accounts-key-management"},"Key Management Actions"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"key management action")," is a change to the account permissions, including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Adding or removing an associated key"),(0,i.kt)("li",{parentName:"ul"},"Changing the weight of an associated key"),(0,i.kt)("li",{parentName:"ul"},"Changing the threshold of any action")),(0,i.kt)("p",null,"Key management actions have validity rules preventing users from locking themselves out of their accounts. For example, one can set a threshold, at most, the sum of the weights of all associated keys."),(0,i.kt)("h4",{id:"accounts-recovery"},"Account security and recovery using key management"),(0,i.kt)("p",null,"This permissions model's purpose is to keep accounts safe from lost or stolen keys while allowing the usage of modern mobile devices. For example, it may be convenient to sign deploys from a smartphone without worrying about the repercussions of losing the phone. The recommended setup is to have a low-weight key on the phone, enough for the deploy threshold but not enough for key management. If the phone is lost or stolen, a key management action using other associated keys from another device (e.g., a home computer) can be used to remove the lost associated key and add a key that resides on a replacement phone."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'It is extremely important to ensure there will always be access to a sufficient number of keys to perform the key management action. Otherwise, future recovery will be impossible (Casper currently does not support "inactive recovery").')),(0,i.kt)("h3",{id:"accounts-context"},"The Account Context"),(0,i.kt)("p",null,"A deploy is a user request to perform some execution on the blockchain (see ",(0,i.kt)("a",{parentName:"p",href:"#execution-semantics-head"},"Execution Semantics"),' for more information). It contains "payment code" and "session code", which are references to stored on-chain contracts or Wasm to be executed. For executable Wasm, its execution and the logic therein occur within the context of the account signing the deploy. This means that the executing Wasm has access to the named keys and main purse of the account\'s context.'),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In the case where there is a reference to stored on-chain Wasm (smart contracts), the execution of the on-chain Wasm will occur in its own separate runtime context. As a result, the stored Wasm will not have access to the named keys or main purse of the calling account.")),(0,i.kt)("h2",{id:"uref-head"},"Unforgeable Reference (URef)"),(0,i.kt)("p",null,"This key type is used for storing any value except ",(0,i.kt)("inlineCode",{parentName:"p"},"Account"),". Additionally, ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s used in Wasm carry permission information to prevent unauthorized usage of the value stored under the key. The runtime tracks this permission information. This means that if malicious Wasm attempts to produce a ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),' with permissions that the Wasm does not have, the Wasm has attempted to "forge" the unforgeable reference, and the runtime will raise a forged ',(0,i.kt)("inlineCode",{parentName:"p"},"URef")," error. Permissions for a ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," can be given across contract calls, allowing data stored under a ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," to be shared in a controlled way. The 32-byte identifier representing the key is generated randomly by the runtime (see ",(0,i.kt)("a",{parentName:"p",href:"#execution-semantics-head"},"Execution Semantics")," for more information). The serialization for ",(0,i.kt)("inlineCode",{parentName:"p"},"Access Rights")," that define the permissions for ",(0,i.kt)("inlineCode",{parentName:"p"},"URefs")," is detailed in the ",(0,i.kt)("a",{parentName:"p",href:"/concepts/serialization-standard"},"CLValues")," section."),(0,i.kt)("h3",{id:"uref-permissions"},"Permissions for ",(0,i.kt)("inlineCode",{parentName:"h3"},"URef"),"s"),(0,i.kt)("p",null,"In the runtime, a ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," carries its permissions called ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessRights"),". Additionally, the runtime tracks what ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessRights")," would be valid for each ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," in each context. The system assumes that a sent ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," is invalid, regardless of declared ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessRights"),", and will check it against the executing context to determine validity on each usage. Only the host logic can add a ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),", in the following ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'It can exist in a set of "known" ',(0,i.kt)("inlineCode",{parentName:"li"},"URef"),"s"),(0,i.kt)("li",{parentName:"ul"},"It can be freshly created by the runtime via the ",(0,i.kt)("inlineCode",{parentName:"li"},"new_uref")," function"),(0,i.kt)("li",{parentName:"ul"},"For called contracts, the caller can pass it in via the arguments to ",(0,i.kt)("inlineCode",{parentName:"li"},"call_contract")),(0,i.kt)("li",{parentName:"ul"},"It can be returned to the caller from ",(0,i.kt)("inlineCode",{parentName:"li"},"call_contract")," via the ",(0,i.kt)("inlineCode",{parentName:"li"},"ret")," function")),(0,i.kt)("p",null,"Note that only valid ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s may be added to the known ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s or cross-call boundaries; this means the system cannot be tricked into accepting a forged ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," by getting it through a contract or stashing it in the known ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s."),(0,i.kt)("p",null,"The ability to pass ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s between contexts via ",(0,i.kt)("inlineCode",{parentName:"p"},"call_contract")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"ret"),", allows them to share state among a fixed number of parties while keeping it private from all others."),(0,i.kt)("h3",{id:"urefs-and-purses"},(0,i.kt)("inlineCode",{parentName:"h3"},"URef"),"s and Purses"),(0,i.kt)("p",null,"Purses represent a unique type of ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," used for accounting measures within a Casper network. ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s exist as a top-level entity, meaning that individual accounts do not own \u2018URef\u2019s. As described above, accounts and contracts possess certain ",(0,i.kt)("inlineCode",{parentName:"p"},"Access Rights"),", allowing them to interact with the given ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),". While an account will possess an associated ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," representing their main purse, this ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," exists as a ",(0,i.kt)("a",{parentName:"p",href:"/concepts/serialization-standard#clvalue-unit"},(0,i.kt)("inlineCode",{parentName:"a"},"Unit"))," and corresponds to a ",(0,i.kt)("em",{parentName:"p"},"balance")," key within the Casper ",(0,i.kt)("em",{parentName:"p"},"mint"),". The individual balance key within the Casper mint is the account's purse, with transfers authorized solely through the associated ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Access Rights")," granted to it."),(0,i.kt)("p",null,"Through this logic, the Casper mint holds all motes on the network and transfers between balance keys at the behest of accounts and contracts as required."),(0,i.kt)("h2",{id:"block-structure-head"},"Block Structure"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"block")," is the primary data structure by which network nodes communicate information about the state of a Casper network. We briefly describe here the format of this data structure."),(0,i.kt)("h3",{id:"block-structure-data"},"Data Fields"),(0,i.kt)("p",null,"A block consists of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"block_hash")),(0,i.kt)("li",{parentName:"ul"},"A header"),(0,i.kt)("li",{parentName:"ul"},"A body")),(0,i.kt)("p",null,"Each of these fields is detailed in the subsequent sections."),(0,i.kt)("h4",{id:"block_hash"},(0,i.kt)("inlineCode",{parentName:"h4"},"block_hash")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"block_hash")," is the ",(0,i.kt)("inlineCode",{parentName:"p"},"blake2b256")," hash of the block header."),(0,i.kt)("h4",{id:"header"},"Header"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/concepts/serialization-standard#serialization-standard-block"},"block header")," contains the following fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"parent_hash")),(0,i.kt)("p",{parentName:"li"},"A list of ",(0,i.kt)("inlineCode",{parentName:"p"},"block_hash"),"es giving the parents of the block.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"state_root_hash")),(0,i.kt)("p",{parentName:"li"},"The global state root hash produced by executing this block's body.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"body_hash")),(0,i.kt)("p",{parentName:"li"},"The hash of the block body.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"random_bit")),(0,i.kt)("p",{parentName:"li"},"A boolean needed for initializing a future era.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"accumulated_seed")),(0,i.kt)("p",{parentName:"li"},"A seed needed for initializing a future era.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"era_end")),(0,i.kt)("p",{parentName:"li"},"Contains equivocation and reward information to be included in the terminal finalized block. It is an optional field.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"timestamp")),(0,i.kt)("p",{parentName:"li"},"The timestamp from when the block was proposed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"era_id")),(0,i.kt)("p",{parentName:"li"},"Era ID in which this block was created.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"height")),(0,i.kt)("p",{parentName:"li"},"The height of this block, i.e., the number of ancestors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"protocol_version")),(0,i.kt)("p",{parentName:"li"},"The version of the Casper network when this block was proposed."))),(0,i.kt)("h4",{id:"body"},"Body"),(0,i.kt)("p",null,"The block body contains an ",(0,i.kt)("strong",{parentName:"p"},"ordered")," list of ",(0,i.kt)("inlineCode",{parentName:"p"},"DeployHashes")," which refer to deploys, and an ",(0,i.kt)("strong",{parentName:"p"},"ordered")," list of ",(0,i.kt)("inlineCode",{parentName:"p"},"DeployHashes")," for native transfers (which are specialized deploys that only transfer tokens between accounts). All deploys, including a specialization such as native transfer, can be broadly categorized as some unit of work that, when executed and committed, affect change to ",(0,i.kt)("a",{parentName:"p",href:"#global-state-intro"},"Global State"),". A valid block may contain no deploys and / or native transfers."),(0,i.kt)("p",null,"The block body also contains the public key of the validator that proposed the block."),(0,i.kt)("p",null,"Refer to the ",(0,i.kt)("a",{parentName:"p",href:"/concepts/serialization-standard"},"Serialization Standard")," for additional information on how blocks and deploy are serialized."),(0,i.kt)("h2",{id:"tokens-head"},"Tokens"),(0,i.kt)("p",null,"Casper is a decentralized Proof-of-Stake blockchain platform that uses a consensus algorithm called ",(0,i.kt)("a",{parentName:"p",href:"/concepts/design/highway"},"Highway"),". Having a unit of value is required to make this system work because users must pay for computation, and validators must have ",(0,i.kt)("a",{parentName:"p",href:"/staking"},"stake")," to bond. In the blockchain space, this unit of value is a ",(0,i.kt)("em",{parentName:"p"},"token"),"."),(0,i.kt)("p",null,"This chapter describes tokens and how one can use them on the Casper platform."),(0,i.kt)("h3",{id:"token-generation-and-distribution"},"Token Generation and Distribution"),(0,i.kt)("p",null,"A blockchain system generally needs a supply of tokens available to pay for computation and reward validators for processing transactions on the network. The initial supply at the launch of Mainnet was 10 billion CSPR. The current supply is available ",(0,i.kt)("a",{parentName:"p",href:"https://api.cspr.live/supply"},"here"),". In addition to the initial supply, the system will have a low rate of inflation, the results of which will be paid out to validators in the form of seigniorage."),(0,i.kt)("p",null,"The number of tokens used to calculate seigniorage is the initial supply of tokens at genesis."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/image/design/token-lifecycle.png",alt:"Image showing the token lifecycle",width:"700"})),(0,i.kt)("h3",{id:"tokens-divisibility"},"Divisibility of Tokens"),(0,i.kt)("p",null,"Typically, a ",(0,i.kt)("em",{parentName:"p"},"token")," is divisible into some number of parts. We call the indivisible units which make up the CSPR token ",(0,i.kt)("em",{parentName:"p"},"motes"),". Each CSPR is divisible into 10",(0,i.kt)("sup",null,"9")," motes. To avoid rounding errors, it is essential to always represent token balances in motes. In comparison, Ether is divisible into 10",(0,i.kt)("sup",null,"18")," parts called Wei."),(0,i.kt)("p",null,"The concept of ",(0,i.kt)("inlineCode",{parentName:"p"},"CSPR")," is human-readable convenience and does not exist within the actual infrastructure of a Casper network. Instead, all transactions deal solely with ",(0,i.kt)("em",{parentName:"p"},"motes"),"."),(0,i.kt)("h3",{id:"tokens-purses-and-accounts"},"Purses and Accounts"),(0,i.kt)("p",null,"All ",(0,i.kt)("a",{parentName:"p",href:"#accounts-head"},"accounts")," on the Casper system have a purse associated with the Casper system mint, called the ",(0,i.kt)("em",{parentName:"p"},"main purse"),". However, for security reasons, the ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," of the main purse is only available to code running in the context of that account (i.e. only in payment or session code). Therefore, the mint's ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," method that accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),"s is not the most convenient when transferring between account main purses. For this reason, Casper supplies a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/system/fn.transfer_to_account.html"},"transfer_to_account")," function, which takes the public key used to derive the identity key of the account. This function uses the mint transfer function with the current account's main purse as the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and the main purse of the account at the provided key as the ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),"."),(0,i.kt)("h3",{id:"mint-contract"},"The Casper Mint Contract"),(0,i.kt)("p",null,"The Casper ",(0,i.kt)("em",{parentName:"p"},"mint")," is a system contract that manages the balance of ",(0,i.kt)("em",{parentName:"p"},"motes")," within a Casper network. These motes are used to pay for computation and bonding on the network. The mint system contract holds all motes on a Casper network but maintains an internal ledger of the balances for each Account's ",(0,i.kt)("em",{parentName:"p"},"main purse"),". Each balance is associated with a ",(0,i.kt)("inlineCode",{parentName:"p"},"URef"),", which is a key to instruct the mint to perform actions on that balance (e.g., transfer motes). Informally, these balances are referred to as ",(0,i.kt)("em",{parentName:"p"},"purses")," and conceptually represent a container for motes. The ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," is how a purse is referenced externally, outside the mint."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessRights")," of the URefs permissions model determines what actions can be performed when using a ",(0,i.kt)("inlineCode",{parentName:"p"},"URef")," associated with a purse."),(0,i.kt)("p",null,"As all URef",(0,i.kt)("inlineCode",{parentName:"p"},"s are unforgeable, the only way to interact with a purse is for a "),"URef",(0,i.kt)("inlineCode",{parentName:"p"},"with appropriate"),"AccessRights` to be validly given to the current context."),(0,i.kt)("p",null,"The basic global state options map onto more standard monetary operations according to the table below:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Global State"),(0,i.kt)("th",{parentName:"tr",align:null},"Action Monetary Action"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Add"),(0,i.kt)("td",{parentName:"tr",align:null},"Deposit (i.e. transfer to)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Write"),(0,i.kt)("td",{parentName:"tr",align:null},"Withdraw (i.e. transfer from) Read Balance check")))),(0,i.kt)("h2",{id:"tokens-mint-interface"},"The mint Contract Interface"),(0,i.kt)("p",null,"The mint system contract exposes the following methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transfer(source: URef, target: URef, amount: Motes) -> TransferResult"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source")," must have at least ",(0,i.kt)("inlineCode",{parentName:"li"},"Write")," access rights, ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," must have at least ",(0,i.kt)("inlineCode",{parentName:"li"},"Add")," access rights"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TransferResult")," may be a success acknowledgment or an error in the case of invalid ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," or insufficient balance in the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," purse"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mint(amount: Motes) -> MintResult"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MintResult")," either gives the created ",(0,i.kt)("inlineCode",{parentName:"li"},"URef")," (with full access rights), which now has a balance equal to the given ",(0,i.kt)("inlineCode",{parentName:"li"},"amount"),"; or an error due to the minting of new motes not being allowed"),(0,i.kt)("li",{parentName:"ul"},"In the Casper mint, only the system account can call ",(0,i.kt)("inlineCode",{parentName:"li"},"mint"),", and it has no private key to produce valid cryptographic signatures, which means only the software itself can execute contracts in the context of the system account"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"create() -> URef"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a convenience function for ",(0,i.kt)("inlineCode",{parentName:"li"},"mint(0)")," which cannot fail because it is always allowed to create an empty purse"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"balance(purse: URef) -> Option<Motes>"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"purse")," must have at least ",(0,i.kt)("inlineCode",{parentName:"li"},"Read")," access rights"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"BalanceResult")," either returns the number of motes held by the ",(0,i.kt)("inlineCode",{parentName:"li"},"purse"),", or nothing if the ",(0,i.kt)("inlineCode",{parentName:"li"},"URef")," is not valid")))))}m.isMDXComponent=!0},9872:function(e,t,a){t.Z=a.p+"assets/images/casper-runtime-9bc2eb0948168ce8a2eef7f037af6ba4.png"},6125:function(e,t,a){t.Z=a.p+"assets/images/generating-urefs-af02bd8d865f5da9599a205bb682678e.png"},7388:function(e,t,a){t.Z=a.p+"assets/images/global-state-54ea70dd3a537dc33f8dec6cc67fc5b7.png"}}]);